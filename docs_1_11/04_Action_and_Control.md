# 模块详解四：动作管理器与控制原理 (Action Manager)

> **目标**：理解大脑发出的指令是如何驱动身体的。

## 1. 神经网络输出的是什么？

很多初学者以为神经网络直接告诉电机：“输出 5 牛顿的力”。其实不是。
在现代足式机器人控制中，我们通常输出的是**目标位置的残差**。

在 `ActionsCfg` 中：
```python
joint_pos = mdp.JointPositionActionCfg(
    ...
    scale=0.25,  # <--- 缩放因子
    use_default_offset=True,
)
```

**控制流程如下：**

1.  **神经网络思考**: 输入当前状态，输出一个介于 -1 到 1 之间的数字（Action）。
2.  **缩放 (Scaling)**: 将这个数字乘以 `0.25`。
    *   *为什么？* 因为 -1 到 1 的动作幅度对于机器人来说太大了，如果直接动那么多，机器人会瞬间抽搐。乘以 0.25 是为了让动作更细腻。
3.  **叠加 (Offset)**: 加上机器人的**默认站立姿态**。
    *   `目标角度 = 默认站立角度 + (神经网络输出 * 0.25)`
    *   这意味着，如果神经网络输出 0，机器人就会自然地站着。它只需要学习**相对于站立姿态的微调**。这比从零开始学习怎么站立要简单得多。

## 2. PD 控制器：虚拟弹簧 (PD Control)

算出了`目标角度`，电机怎么执行呢？这里用到了经典的 **PD 控制原理**。

你可以把机器人的关节想象成连着一根**弹簧 (P)** 和一个**阻尼器 (D)**。

*   **P (Proportional / 刚度)**: 
    *   代码配置: `stiffness=40.0`
    *   含义: 弹簧有多硬。如果当前角度和目标角度不一样，P项就会产生一个力矩把关节拉过去。P 越大，拉得越猛，位置越准，但也越容易震荡。
*   **D (Derivative / 阻尼)**:
    *   代码配置: `damping=2.5`
    *   含义: 阻尼器有多粘。它产生一个与运动速度相反的力。就像在水里挥动手臂。D 项的作用是抑制震荡，让动作停得更稳。

### 公式 (小白版)
$$输出力矩 = P \times (目标位置 - 当前位置) - D \times (当前速度)$$

*   如果你离目标很远，P项发力拉你。
*   如果你跑得太快冲过头了，D项发力拽住你。

## 3. 总结

`ActionsCfg` 定义了：
1.  **控制谁**：6 个关节（左右髋、大腿、膝盖）。
2.  **怎么控制**：位置控制模式（PD模式）。
3.  **安全限制**：如果神经网络发疯了，输出了巨大的力，我们在底层会限制最大力矩为 300Nm，最大速度为 100 rad/s，防止机器人自毁。

这就是连接虚拟大脑与虚拟躯体的最后一道桥梁。
